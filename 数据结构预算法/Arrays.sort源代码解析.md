**Java Arrays中提供了对所有类型的排序。其中主要分为Primitive(8种基本类型)和Object两大类。**

**基本类型：采用调优的快速排序；**

**对象类型：采用改进的归并排序。**

## 一、对于基本类型源码分析如下（以int[]为例）：

　　**Java对Primitive（int，float等原型数据）数组采用快速排序，对Object对象数组采用归并排序。对这一区别，sun在<<The Java Tutorial>>中做出的解释如下：**

​	也就是说，优化的归并排序既快速（nlog(n)）又稳定。

　　**对于对象的排序，稳定性很重要。**比如成绩单，一开始可能是按人员的学号顺序排好了的，现在让我们用成绩排，那么你应该保证，本来张三在李四前面，即使他们成绩相同，张三不能跑到李四的后面去。

　　而**快速排序是不稳定的**，而且最坏情况下的时间复杂度是O(n^2)。

　　另外，**对象数组中保存的只是对象的引用，这样多次移位并不会造成额外的开销，但是，对象数组对比较次数一般比较敏感，有可能对象的比较比单纯数的比较开销大很多。归并排序在这方面比快速排序做得更好，这也是选择它作为对象排序的一个重要原因之一。**

　　**排序优化：实现中快排和归并都采用递归方式，而在递归的底层，也就是待排序的数组长度小于7时，直接使用冒泡排序，而不再递归下去。**

　　分析：长度为6的数组冒泡排序总比较次数最多也就1+2+3+4+5+6=21次，最好情况下只有6次比较。而快排或归并涉及到递归调用等的开销，其时间效率在n较小时劣势就凸显了，因此这里采用了冒泡排序，这也是对快速排序极重要的优化。

​	**源码中的快速排序，主要做了以下几个方面的优化：**

　　1）当待排序的数组中的元素个数较少时，源码中的阀值为7，采用的是插入排序。**尽管插入排序的时间复杂度为0(n^2)，但是当数组元素较少时，插入排序优于快速排序，因为这时快速排序的递归操作影响性能。**

　　2）**较好的选择了划分元（基准元素）。能够将数组分成大致两个相等的部分，避免出现最坏的情况。**例如当数组有序的的情况下，选择第一个元素作为划分元，将使得算法的时间复杂度达到O(n^2).

　　**源码中选择划分元的方法:**

　　　　当数组大小为 size=7 时 ，取数组中间元素作为划分元。**int n=m>>1;(此方法值得借鉴)**

　　　　当数组大小 7<size<=40时，取首、中、末三个元素中间大小的元素作为划分元。

　　　　当数组大小 size>40 时 ，从待排数组中较均匀的选择9个元素，选出一个伪中数做为划分元。

　　3）根据划分元 v ，形成不变式 v* (<v)* (>v)* v*

　　**普通的快速排序算法，经过一次划分后，将划分元排到素组较中间的位置，左边的元素小于划分元，右边的元素大于划分元，而没有将与划分元相等的元素放在其附近，这一点，在Arrays.sort()中得到了较大的优化。**

　　举例：15、93、15、41、6、15、22、7、15、20

　　因  7<size<=40,所以在15、6、和20 中选择v = 15 作为划分元。

　　经过一次换分后： 15、15、7、6、41、20、22、93、15、15. 与划分元相等的元素都移到了素组的两边。

　　接下来将与划分元相等的元素移到数组中间来，形成：7、6、15、15、15、15、41、20、22、93.

　　最后递归对两个区间进行排序[7、6]和[41、20、22、93].





https://www.cnblogs.com/gw811/archive/2012/10/04/2711746.html