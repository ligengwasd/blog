# 1 - 对象是否已死

## 1.1 引用计数法

## 1.2 GC Roots引用链

可作为GC Roots的对象：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量属性引用的对象
- 本地方法JNI引用的对象

## 1.3 引用

- 强引用

  绝不回收。

- 软引用

  快要内存溢出的时候被回收。

- 弱引用

  下一次GC的时候一定被回收。

- 虚引用

  创建虚引用的目的是在对象被GC回收的时候收到一个通知。

## 1.4 回收方法区

回收对象：废弃常量，无用的类。

**废弃常量：**

- 字面量，符号引用没有被引用则回收

**无用的类：**

- 该类所有实例都被回收
- 加载该类的classloader被回收
- 该类的class对象没有被引用。无法通过反射访问该类

可通过jvm启动参数设置是否回收无用类。

# 2 - 垃圾收集算法

## 2.1 标记清除

## 2.2 复制算法



Eden：FromSurvivor：ToSurvivor = 8：1：1

对象放在Eden和Survivor，清理的时候，存活的复制到另一块Survivor。

## 2.3 标记整理

存活对象移动到一端，清理边界以外的内存块。

## 2.4 分代收集算法

新生代：存活的对象少，使用复制算法。

老年代：存活的对象多，使用标记清除或标记整理。

# 3 - HotSpot算法实现

todo

# 4 - 垃圾收集器

连线的表示可以配合使用

<img width="1008" height="500" src="https://raw.githubusercontent.com/ligengwasd/blog/master/读书笔记-深入理解java虚拟机/images/2.50.57.png"/>

## 4.1 serial收集器

- 单线程。GC时必须暂停用户线程。
- 效率高
- 必须stop the world
- 一般用在client端

## 4.2 parnew收集器

- serial收集器的多线程版。GC和用户线程可同时执行。第一款并发收集器。
- 除了serial收集器，只有它能和cms配合使用。

## 4.3 parallel scavenge收集器

- 吞吐量收集器

## 4.4 serial old搜集器

- serial收集器的老年版
- 单线程
- 采用“标记-整理”算法

## 4.5 parallel old收集器

- parallel scavenge收集器收集器的老年版
- 多线程
- 采用“标记-整理”算法

parallel系列吞吐量有限。

## 4.6 cms收集器

Concurrent Mark Sweep 收集器。基于标记-清除算法。

运行过程包含四个步骤

- 初始标记
- 并发标记
- 重新标记
- 并发清除



# 5 - G1收集器





