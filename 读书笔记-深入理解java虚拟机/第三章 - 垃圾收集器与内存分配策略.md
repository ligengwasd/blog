# 1 - 对象是否已死

## 1.1 引用计数法

## 1.2 GC Roots引用链

可作为GC Roots的对象：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量属性引用的对象
- 本地方法JNI引用的对象

## 1.3 引用

- 强引用

  绝不回收。

- 软引用

  快要内存溢出的时候被回收。

- 弱引用

  下一次GC的时候一定被回收。

- 虚引用

  创建虚引用的目的是在对象被GC回收的时候收到一个通知。

## 1.4 回收方法区

回收对象：废弃常量，无用的类。

**废弃常量：**

- 字面量，符号引用没有被引用则回收

**无用的类：**

- 该类所有实例都被回收
- 加载该类的classloader被回收
- 该类的class对象没有被引用。无法通过反射访问该类

可通过jvm启动参数设置是否回收无用类。

# 2 - 垃圾收集算法

## 2.1 标记清除

## 2.2 复制算法



Eden：FromSurvivor：ToSurvivor = 8：1：1

对象放在Eden和Survivor，清理的时候，存活的复制到另一块Survivor。

## 2.3 标记整理

存活对象移动到一端，清理边界以外的内存块。

## 2.4 分代收集算法

新生代：存活的对象少，使用复制算法。

老年代：存活的对象多，使用标记清除或标记整理。

# 3 - HotSpot算法实现

todo

# 4 - 垃圾收集器

连线的表示可以配合使用

<img width="1008" height="952" src="https://raw.githubusercontent.com/ligengwasd/blog/master/读书笔记-深入理解java虚拟机/images/2.50.57.png"/>

