# 1 - 运行时数据区域

## 1.1 程序计数器

线程私有，一个线程一个一个程序计数器。

如果线程正在执行java方法，存的是正在执行的字节码指令。

如果正在执行的是native方法，为空。

唯一不会抛出OutOfMemoryError的区域

## 1.2 java虚拟机栈

线程私有。

每个方法执行的同时都会创建一个栈帧用于**存储局部变量表，操作数栈，动态链接，方法出口**等信息。每一个方法从调用到执行的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表所需内存空间大小在编译期就能确定。进入方法后，需要再帧中分配多大的空间是固定的，运行期不可变。（long、double）占两个slot，其他类型占一个。

## 1.3 本地方法栈

## 1.4 java堆

所有线程共享

## 1.5 方法区

用于被虚拟机加载的**类信息(字段、方法、接口等)、常量池、静态变量、即时编译器编译之后的代码**等数据。

## 1.6 运行时常量池

是方法区的一部分。

用于存放编译期生成的**字面量**和**符号引用**。

常量并并一定是编译才能产生，也就是并非预置class文件中常量池的内容才能进入运行时常量池，运行期间也可以加入。比如`String.intern()`方法。

## 1.7 直接内存

本机直接内存的大小不受堆大小的限制。

如果堆内存和直接内大于物理内存，会OutOfMemoryError。

# 2- 对象创建及内存布局

## 2.1 对象创建

对象：指普通对象，不包括数组和class对象。

1. new指令：先去常量池中定位到一个类的符号引用，并检查该类是否被加载、解析、初始化，如果没有先执行类加载过程。

2. 分配内存空间

   对象所需内存大小在类加载完成后即可确定。

   保证分配内存空间的操作的线程安全性：

   - 虚拟机采用cas配上失败重试的方式保证更新操作的原子性。
   - 每个线程预先分配一小块内存，然后各个线程创建对象的时候在自己的内存块上分配。

   内存分配完成后，会被初始化为类型零值。（这就是为什么声明 int i； i默认为0）

3. 虚拟机需要对对象进行必要的设置。

   例如是哪个类的实例，如何才能找到类的元数据，对象的哈希码，对象的GC分代年龄。这些信息存放在对象的对象头(Object Header)里。

4. 执行init指令，初始化对象。

## 2.2 对象内存布局

**包含三块：对象头（Header）、实例数据、对齐填充**

对象头：

- MarkWord：哈希码（HashCode），GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳。（一般为32位或者64位）
- 类型指针：指向它的类元数据的指针，以此确定是哪个类的实例。（不是所有的虚拟机实现都有类型指针）
- 如果对象是数组，对象头还会保存数组长度。（普通对象可以从对象的元数据信息确定对象大小，但是数组无法确定大小）

实例数据：各种类型的字段内容，包括从父类继承的。

对齐填充：非必然存在。只是占位符。HotSpot VM的自动内存管理系统要求对象起始地址必须是8的整数倍，也就是对象的大小必须是8字节的整数倍，对象头刚好是8的倍数，当实例数据不是8的倍数时，用对齐填充补全。

## 2.3 对象的访问定位

- 使用句柄访问

  Java堆中划分出一块内存来作为句柄池。reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。如图：

  <img width="750" height="340" src="https://raw.githubusercontent.com/ligengwasd/blog/master/读书笔记-MyBatis技术内幕/images/1.36.10.png"/>

- 直接访问

  <img width="750" height="340" src="https://raw.githubusercontent.com/ligengwasd/blog/master/读书笔记-MyBatis技术内幕/images/1.36.21.png"/>

