### 12.3.2 内存间交互操作

**lock**：作用于主内存变量。表示该标量被一条线程独占。

**unlock**：作用于主内存变量。

**read**：作用于主内存变量。把变量值从主内存传递到工作内存。

**load**：作用于工作内存变量。把read的值放入工作内存的变量副本中。(**read和load必须一起**)

**use**：作用于工作内存变量。把工作内存变量的值传递给执行引擎。

**assign**：作用于工作内存变量。执行引擎把值赋给工作内存变量。

**store**：作用于工作内存变量。和load相反，把变量值从工作内存传递到主内存。

**write**：作用于主内存变量。把store操作的值放入主内存变量。(**store和write必须一起**)

### 12.3.3 volatile变量的特殊规则 

**可见性**：

**禁止指令重排序**：

规则：

- load和use必须连续一起(包含read)

  保证每次都从主内存读

- assign和store必须连续一起(包含write)

  保证每次修改都及时更新到了主内存

- 禁止重排序：

  A：线程T，变量V，的use|assign操作

  F：和A关联的，load|store操作

  P：和F关联的，read|write操作

  

  B：线程T，变量W，的use|assign操作

  G：和B关联的，load|store操作

  Q：和G关联的，read|write操作

  

  **那么，A先于B，P一定先于Q**

  

### 12.4.3 线程状态转换

- **新建(New)**：
- **运行(Runable)：**
- **无限期等待(Waiting)：**
- **限期等待(Timed Waiting)：**
- **阻塞(Blocked)：**
- **结束(Terminated)：**



**线程阻塞和等待的区别**
  		实际上不用可以区分两者, 因为两者都会暂停线程的执行. 两者的区别是: 进入	waiting状态是线程主动的, 而进入blocked状态是被动的. 更进一步的说, 进入blocked状态是在同步(synchronized代码之外), 而进入waiting状态是在同步代码之内.

**sleep()和wait/notify机制**

- **sleep()方法**
  		sleep()方法是定义在Thread上的native方法, 在设定时间段内(精度取决于CPU)阻塞线程的执行, 但是并不更改线程的锁持有情况.
- **wait/notify机制**
  wait()方法是定义在Object上的方法, 是java语言级的方法, 需要在同步块或者同步方法中进行调用, 会释放锁, 并进入锁对象的等待队列, 需要等到其他线程调用notify()方法释放锁后(实际上该线程同步块运行结束后才会释放锁), 重新竞争锁.
 - **两者的共同点是**
    		都暂时停止线程的执行, 线程本身不会占用CPU时间片.区别是调用了sleep方法的线程直接受CPU调度, 而wait则是等待另外的java线程在持有同一个对象锁的同步块/方法中进行notify调用.





 
